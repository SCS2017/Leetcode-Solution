/* 
给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：
() 得 1 分。
AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。
(A) 得 2 * A 分，其中 A 是平衡括号字符串。

示例 1：
输入： "()"
输出： 1

示例 2：
输入： "(())"
输出： 2

示例 3：
输入： "()()"
输出： 2

示例 4：
输入： "(()(()))"
输出： 6

提示：
S 是平衡括号字符串，且只含有 ( 和 ) 。
2 <= S.length <= 50
*/

#include <bits/stdc++.h>
using namespace std;


/* 
只用一个变量 cnt 来记录当前在第几层括号之中，因为本题的括号累加值是有规律的，"()" 是1，因为最中间的括号在0层括号内，2^0 = 1。
"(())" 是2，因为最中间的括号在1层括号内，2^1 = 2。"((()))" 是4，因为最中间的括号在2层括号内，2^2 = 4。
因此类推，其实只需要统计出最中间那个括号外变有几个括号，就可以直接算出整个多重包含的括号字符串的值，
*/
class Solution {
public:
    int scoreOfParentheses(string S) {
        int res = 0, cnt = 0;
        for(int i = 0; i < S.size(); ++i){
            S[i] == '(' ? ++cnt : --cnt;
            if(S[i] == ')' && S[i-1] == '(')
                res += (1 << cnt);
            
        }
        return res;
    }
};

int main(){
    
    return 0;
}
